
#include "TimerOne.h"
#include "DVR8825.h"

#define PONTOS 50
#define tempo_interpolacao 2000

#define transistor 3
#define botao A8
#define botao_start A9
#define pot_braco A1
#define pot_base A2
#define a_pas 1.75 
#define led_verde 43
#define led_vermelho 45
#define led_amarelo 47
#define BASE 0
#define TOPO 1

#define mm_braco 356

DVR8825 topo(13, 12, 11, 10, 9, 8); DVR8825 base(7, 6, 5, 4, 3, 8); DVR8825 braco(22, 23);

float x[PONTOS]; float a[PONTOS]; float z[PONTOS];

int p_n = 0;
int estado = 0;
int contador = 0;
float off_b;  float off_to;  float off_br;
int done_b = 0; int done_t = 0; int done_br = 0;
int done = 0;

float FCanguloB = 10; float FCanguloT; float FCanguloBR;

void sinaliza(); // Responta luminosa para o operador
void aprender(); // Marcando coordenadas
void prontidao(); // Aguardando inicio do programa
void trabalhando(); // Executando movimento

void setup() {
  pinMode(pot_base, INPUT);
  pinMode(pot_braco, INPUT);
  pinMode(transistor, OUTPUT);
  pinMode(led_verde, OUTPUT);
  pinMode(led_vermelho, OUTPUT);
  pinMode(led_amarelo, OUTPUT);
  Serial.begin(250000);
  Serial.setTimeout(5);
  Timer1.initialize(100000);
  Timer1.attachInterrupt(sinaliza);
  pinMode(botao, INPUT);
  pinMode(botao_start, INPUT);
}

void loop() {
  while (estado == 0) {
    if (analogRead(botao)==0) {
      delay(200);
      estado = 1;
    }
  }
  switch (estado)
  {
    case 1:
      aprender();
      break;
    case 2:
      prontidao();
      break;
    case 4:
      for ( int i = 0 ; i < p_n ; i++ ) {
        trabalhando(z[i], a[i], x[i]);}
        delay(tempo_interpolacao);
      
        for ( int i = p_n ; i > -1 ; i-- ) {
        trabalhando(z[i], a[i], x[i]);}
        delay(tempo_interpolacao);
      break;
  }
}

void prontidao() {
  while (analogRead(botao)==0) {
    delay(200);
  }
  estado = 4;
}

void aprender() {
  digitalWrite(transistor, LOW);
  estado = 1;
  while (estado == 1) {
    if (analogRead(botao)==0) {
      digitalWrite(led_amarelo, 1);
      uno(1);
      a[p_n] = FCanguloT ;
      x[p_n] = extencao(pot_braco);
      z[p_n] = rebolado(pot_base);
      p_n++;
      delay(200);
      digitalWrite(led_amarelo, 0);
    }
    if (analogRead(botao_start)==0) {
      delay(200);
      estado = 2;
    }
  }
  digitalWrite(transistor, HIGH);
}

float extencao(int pin) {
  int x = analogRead(pin);
  float mm = map(x, 0, 1023, 0, mm_braco);
  return mm;
}
float rebolado(int pin) {
  int x = analogRead(pin);
  float graus = map(x, 0, 1023, 0, 270);
  return graus;
}

void uno(float req) {
  if (req == 0) {
    Serial.print('t');
    FCanguloB = Serial.parseFloat();
  }
  if (req == 1) {
    Serial.print(116);
    FCanguloT = Serial.parseFloat();
  }
}

void alinhaBase (float ref) {
  if (done_b == 0) {
    uno(0);
    if (FCanguloB != ref) {
      int inteiro = floor(ref); int resto = FCanguloB - (inteiro - 1); if (resto < 0) {
        resto = resto * -1;
      }
      if (resto < 1) {
        if (ref > FCanguloB) {
          base.marche(1, 3);
          off_b += a_pas / 8 ;
        }
        if (FCanguloB > ref) {
          base.marche(0, 3);
          off_b -= a_pas / 8 ;
        }
      } else {
        if (ref > FCanguloB) {
          base.marche(1, 1);
          off_b += a_pas / 2 ;
        }
        if (FCanguloB > ref) {
          base.marche(0, 1);
          off_b -= a_pas / 2 ;
        }
      }
    } else done_b = 1;
  }
}

void alinhaTopo (float ref) {
  if (done_t == 0) {
    uno(1);
    if (FCanguloT != ref) {
      int inteiro = floor(ref); int resto = FCanguloT - (inteiro - 1); if (resto < 0) {
        resto = resto * -1;
      }
      if (resto < 1) {
        if (ref > FCanguloT) {
          topo.marche(1, 3);
          off_to += a_pas / 8 ;
        }
        if (FCanguloT > ref) {
          topo.marche(0, 3);
          off_to -= a_pas / 8 ;
        }
      } else {
        if (ref > FCanguloT) {
          topo.marche(1, 1);
          off_to += a_pas / 2 ;
        }
        if (FCanguloT > ref) {
          topo.marche(0, 1);
          off_to -= a_pas / 2 ;
        }
      }
    } else done_t = 1;
  }
}

void alinhaBraco (float ref) {
  if (done_br == 0) {
    if (FCanguloBR != ref) {
      int inteiro = floor(ref); int resto = FCanguloBR - (inteiro - 1); if (resto < 0) {
        resto = resto * -1;
      }
      if (resto < 1) {
        if (ref > FCanguloBR) {
          braco.marche(1, 3);
          off_br += a_pas / 8 ;
        }
        if (FCanguloBR > ref) {
          braco.marche(0, 3);
          off_br -= a_pas / 8 ;
        }
      } else {
        if (ref > FCanguloBR) {
          braco.marche(1, 1);
          off_br += a_pas / 2 ;
        }
        if (FCanguloBR > ref) {
          braco.marche(0, 1);
          off_br -= a_pas / 2 ;
        }
      }
    } else done_br = 1;
  }
}

void trabalhando (float ref_b, float ref_t, float ref_br) {
  done = done_b + done_t + done_br;
  while (done < 3) {
    if (digitalRead(botao)) {
      while (!digitalRead(botao)) {
        estado = 5;
      }
    }
    estado = 4;
    alinhaBase(ref_b);
    alinhaTopo(ref_t);
    alinhaBraco(ref_br);
  }
}

void sinaliza() {
  switch (estado)
  {
    case 1: // aprendendo
    digitalWrite(led_amarelo, 0);
    digitalWrite(led_vermelho, 0);
      if (contador > 9){contador = 0;}
      if (contador == 0 || contador == 1) {
        digitalWrite(led_verde, 1);
      }
      if (contador == 3) {
        digitalWrite(led_verde, 0);
      }
      if (contador == 4 || contador == 5) {
        digitalWrite(led_verde, 1);
      }
      if (contador > 5 ) {
        digitalWrite(led_verde, 0);
      }      
      contador++;
      break;

    case 2: // prontidÃ£o
    digitalWrite(led_amarelo, 0);
    digitalWrite(led_vermelho, 0);
      if (contador > 9){contador = 0;}
      digitalWrite(led_verde, 1);
      
      contador++;
      break;

    case 3:
    digitalWrite(led_amarelo, 0);
      if (contador > 9) {contador = 0;}
      if(contador < 5){
        digitalWrite(led_verde, 0);digitalWrite(led_vermelho, 1);
      } else {digitalWrite(led_verde, 1);digitalWrite(led_vermelho, 0);}

      contador++;
      break;

    case 4: //alinhando
      digitalWrite(led_amarelo,0);
      if (contador > 3) {contador = 0;}
      if(contador == 0 || contador == 1){
        digitalWrite(led_verde, 0);digitalWrite(led_vermelho, 1);
      } else {digitalWrite(led_verde, 1);digitalWrite(led_vermelho, 0);}

      contador++;
      break;

    case 5: //pausado
      digitalWrite(led_amarelo,0);
      digitalWrite(led_verde, 1);
      if (contador > 9) {contador = 0;}
      if(contador < 5){digitalWrite(led_vermelho, 1);}
      else digitalWrite(led_vermelho, 0);
      contador++;
      break;
  }
}

/*
  if (resto > 2) {
    if (GyroY > savio) {
      motorA.marche(1, 0);
      savio = savio + a_pas ;
    }
    if (savio > GyroY) {
      motorA.marche(0, 0);
      savio = savio - a_pas ;
    }
  }else if (resto < .5 && resto > 0) {
    if (GyroY > savio) {
      motorA.marche(1, 5);
      savio = savio + a_pas / 32 ;
    }
    if (savio > GyroY) {
      motorA.marche(0, 5);
      savio = savio - a_pas / 32 ;
    }
  }else if (resto < 1 && resto > .5) {
    if (GyroY > savio) {
      motorA.marche(1, 3);
      savio = savio + a_pas / 8 ;
    }
    if (savio > GyroY) {
      motorA.marche(0, 3);
      savio = savio - a_pas / 8 ;
    }
  } else if (resto < 2 && resto > 1) {
    if (GyroY > savio) {
      motorA.marche(1, 2);
      savio = savio + a_pas / 4 ;
    }
    if (savio > GyroY) {
      motorA.marche(0, 2);
      savio = savio - a_pas / 4 ;
    }
  }
*/

